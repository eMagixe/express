import { defineComponent, computed, h as h$1, onServerPrefetch, toValue, getCurrentInstance, ref, shallowRef, nextTick, unref, toRef, provide, cloneVNode, createElementBlock } from 'vue';
import { Icon, getIcon, loadIcon } from '@iconify/vue';
import { getIconCSS } from '@iconify/utils/lib/css/icon';
import { a as h, c as ke, g as Z, u as Wt, i as jo, j as S } from './server.mjs';
import { debounce } from 'perfect-debounce';
import '../nitro/nitro.mjs';
import 'node:http';
import 'node:https';
import 'node:events';
import 'node:buffer';
import 'node:fs';
import 'node:path';
import 'node:crypto';
import 'node:url';
import '@iconify/utils';
import 'consola';
import 'vue-router';
import 'tailwindcss/colors';
import 'vue/server-renderer';
import '../routes/renderer.mjs';
import 'vue-bundle-renderer/runtime';
import 'unhead/server';
import 'devalue';
import 'unhead/plugins';
import 'unhead/utils';

async function R(e,t){if(!e)return null;const o=getIcon(e);if(o)return o;let a;const r=loadIcon(e).catch(()=>(console.warn(`[Icon] failed to load icon \`${e}\``),null));return t>0?await Promise.race([r,new Promise(s=>{a=setTimeout(()=>{console.warn(`[Icon] loading icon \`${e}\` timed out after ${t}ms`),s();},t);})]).finally(()=>clearTimeout(a)):await r,getIcon(e)}function q(e){const t=ke().icon,o=(t.collections||[]).sort((a,r)=>r.length-a.length);return computed(()=>{const a=e(),r=a.startsWith(t.cssSelectorPrefix)?a.slice(t.cssSelectorPrefix.length):a,s=t.aliases?.[r]||r;if(!s.includes(":")){const n=o.find(i=>s.startsWith(i+"-"));return n?n+":"+s.slice(n.length+1):s}return s})}function x(e,t){if(e!==false)return e===true||e===null?t:e}const z="NUXT_ICONS_SERVER_CSS";function ee(e){return e.replace(/([^\w-])/g,"\\$1")}const te=defineComponent({name:"NuxtIconCss",props:{name:{type:String,required:true},customize:{type:[Function,Boolean,null],default:null,required:false}},setup(e){const t=h(),o=ke().icon,a=computed(()=>e.name?o.cssSelectorPrefix+e.name:""),r=computed(()=>"."+ee(a.value));function s(n,i=true){let l=r.value;o.cssWherePseudo&&(l=`:where(${l})`);const y=getIconCSS(n,{iconSelector:l,format:"compressed",customise:x(e.customize,o.customize)});return o.cssLayer&&i?`@layer ${o.cssLayer} { ${y} }`:y}return onServerPrefetch(async()=>{if(!(Z().icon||{})?.serverKnownCssClasses?.includes(a.value)){const i=await R(e.name,o.fetchTimeout).catch(()=>null);if(!i)return null;let l=t.vueApp._context.provides[z];if(l||(l=t.vueApp._context.provides[z]=new Map,t.runWithContext(()=>{Wt({style:[()=>{let c=Array.from(l.values()).sort().join("");return o.cssLayer&&(c=`@layer ${o.cssLayer} {${c}}`),{innerHTML:c}}]},{tagPriority:"low"});})),e.name&&!l.has(e.name)){const y=s(i,false);l.set(e.name,y);}return null}}),()=>h$1("span",{class:["iconify",a.value]})}}),ae=Symbol.for("nuxt:client-only"),he=defineComponent({name:"ClientOnly",inheritAttrs:false,props:["fallback","placeholder","placeholderTag","fallbackTag"],setup(e,{slots:t,attrs:o}){const a=shallowRef(false),r=getCurrentInstance();return r&&(r._nuxtClientOnly=true),provide(ae,true),()=>{if(a.value){const l=t.default?.();return l&&l.length===1?[cloneVNode(l[0],o)]:l}const s=t.fallback||t.placeholder;if(s)return h$1(s);const n=e.fallback||e.placeholder||"",i=e.fallbackTag||e.placeholderTag||"span";return createElementBlock(i,o,n)}}});function ne(...e){const t=typeof e[e.length-1]=="string"?e.pop():void 0;re(e[0],e[1])&&e.unshift(t);let[o,a,r={}]=e;const s=computed(()=>toValue(o));if(typeof s.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof a!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const n=h();r.server??=true,r.default??=ce,r.getCachedData??=B,r.lazy??=false,r.immediate??=true,r.deep??=jo.deep,r.dedupe??="cancel",r._functionName,n._asyncData[s.value];function i(){const u={cause:"initial",dedupe:r.dedupe};return n._asyncData[s.value]?._init||(u.cachedData=r.getCachedData(s.value,n,{cause:"initial"}),n._asyncData[s.value]=se(n,s.value,a,r,u.cachedData)),()=>n._asyncData[s.value].execute(u)}const l=i(),y=n._asyncData[s.value];if(y._deps++,r.server!==false&&n.payload.serverRendered&&r.immediate){const u=l();getCurrentInstance()?onServerPrefetch(()=>u):n.hook("app:created",async()=>{await u;});}const f={data:D(()=>n._asyncData[s.value]?.data),pending:D(()=>n._asyncData[s.value]?.pending),status:D(()=>n._asyncData[s.value]?.status),error:D(()=>n._asyncData[s.value]?.error),refresh:(...u)=>n._asyncData[s.value]?._init?n._asyncData[s.value].execute(...u):i()(),execute:(...u)=>f.refresh(...u),clear:()=>{const u=n._asyncData[s.value];if(u?._abortController)try{u._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"));}finally{u._abortController=void 0;}L(n,s.value);}},_=Promise.resolve(n._asyncDataPromises[s.value]).then(()=>f);return Object.assign(_,f),_}function D(e){return computed({get(){return e()?.value},set(t){const o=e();o&&(o.value=t);}})}function re(e,t){return !(typeof e=="string"||typeof e=="object"&&e!==null||typeof e=="function"&&typeof t=="function")}function L(e,t){t in e.payload.data&&(e.payload.data[t]=void 0),t in e.payload._errors&&(e.payload._errors[t]=void 0),e._asyncData[t]&&(e._asyncData[t].data.value=unref(e._asyncData[t]._default()),e._asyncData[t].error.value=void 0,e._asyncData[t].status.value="idle"),t in e._asyncDataPromises&&(e._asyncDataPromises[t]=void 0);}function oe(e,t){const o={};for(const a of t)o[a]=e[a];return o}function se(e,t,o,a,r){e.payload._errors[t]??=void 0;const s=a.getCachedData!==B,n=o,i=a.deep?ref:shallowRef,l=r!==void 0,y=e.hook("app:data:refresh",async f=>{(!f||f.includes(t))&&await c.execute({cause:"refresh:hook"});}),c={data:i(l?r:a.default()),pending:computed(()=>c.status.value==="pending"),error:toRef(e.payload._errors,t),status:shallowRef("idle"),execute:(...f)=>{const[_,u=void 0]=f,m=_&&u===void 0&&typeof _=="object"?_:{};if(e._asyncDataPromises[t]&&(m.dedupe??a.dedupe)==="defer")return e._asyncDataPromises[t];{const d="cachedData"in m?m.cachedData:a.getCachedData(t,e,{cause:m.cause??"refresh:manual"});if(d!==void 0)return e.payload.data[t]=c.data.value=d,c.error.value=void 0,c.status.value="success",Promise.resolve(d)}c._abortController&&c._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),c._abortController=new AbortController,c.status.value="pending";const p=new AbortController,I=new Promise((d,v)=>{try{const E=m.timeout??a.timeout,g=ie([c._abortController?.signal,m?.signal],p.signal,E);if(g.aborted){const b=g.reason;v(b instanceof Error?b:new DOMException(String(b??"Aborted"),"AbortError"));return}return g.addEventListener("abort",()=>{const b=g.reason;v(b instanceof Error?b:new DOMException(String(b??"Aborted"),"AbortError"));},{once:!0,signal:p.signal}),Promise.resolve(n(e,{signal:g})).then(d,v)}catch(E){v(E);}}).then(async d=>{let v=d;a.transform&&(v=await a.transform(d)),a.pick&&(v=oe(v,a.pick)),e.payload.data[t]=v,c.data.value=v,c.error.value=void 0,c.status.value="success";}).catch(d=>{if(e._asyncDataPromises[t]&&e._asyncDataPromises[t]!==I||c._abortController?.signal.aborted)return e._asyncDataPromises[t];if(typeof DOMException<"u"&&d instanceof DOMException&&d.name==="AbortError")return c.status.value="idle",e._asyncDataPromises[t];c.error.value=S(d),c.data.value=unref(a.default()),c.status.value="error";}).finally(()=>{p.abort(),delete e._asyncDataPromises[t];});return e._asyncDataPromises[t]=I,e._asyncDataPromises[t]},_execute:debounce((...f)=>c.execute(...f),0,{leading:true}),_default:a.default,_deps:0,_init:true,_hash:void 0,_off:()=>{y(),e._asyncData[t]?._init&&(e._asyncData[t]._init=false),s||nextTick(()=>{e._asyncData[t]?._init||(L(e,t),c.execute=()=>Promise.resolve());});}};return c}const ce=()=>{},B=(e,t,o)=>{if(t.isHydrating)return t.payload.data[e];if(o.cause!=="refresh:manual"&&o.cause!=="refresh:hook")return t.static.data[e]};function ie(e,t,o){const a=e.filter(n=>!!n);if(typeof o=="number"&&o>=0){const n=AbortSignal.timeout?.(o);n&&a.push(n);}if(AbortSignal.any)return AbortSignal.any(a);const r=new AbortController;for(const n of a)if(n.aborted){const i=n.reason??new DOMException("Aborted","AbortError");try{r.abort(i);}catch{r.abort();}return r.signal}const s=()=>{const i=a.find(l=>l.aborted)?.reason??new DOMException("Aborted","AbortError");try{r.abort(i);}catch{r.abort();}};for(const n of a)n.addEventListener?.("abort",s,{once:true,signal:t});return r.signal}const le=defineComponent({name:"NuxtIconSvg",props:{name:{type:String,required:true},customize:{type:[Function,Boolean,null],default:null,required:false}},setup(e,{slots:t}){h();const o=ke().icon,a=q(()=>e.name),r="i-"+a.value;return a.value&&onServerPrefetch(async()=>{await ne(r,async()=>await R(a.value,o.fetchTimeout),{deep:false});}),()=>h$1(Icon,{icon:a.value,ssr:true,customise:x(e.customize,o.customize)},t)}}),ue=defineComponent({name:"NuxtIcon",props:{name:{type:String,required:true},mode:{type:String,required:false,default:null},size:{type:[Number,String],required:false,default:null},customize:{type:[Function,Boolean,null],default:null,required:false}},setup(e,{slots:t}){const o=h(),a=ke().icon,r=q(()=>e.name),s=computed(()=>o.vueApp?.component(r.value)||((e.mode||a.mode)==="svg"?le:te)),n=computed(()=>{const i=e.size||a.size;return i?{fontSize:Number.isNaN(+i)?i:i+"px"}:null});return ()=>h$1(s.value,{...a.attrs,name:r.value,class:a.class,style:n.value,customize:e.customize},t)}}),be=Object.freeze(Object.defineProperty({__proto__:null,default:ue},Symbol.toStringTag,{value:"Module"}));

export { ue as _, he as a, be as i };
//# sourceMappingURL=index-NPZ-ilWx.mjs.map
